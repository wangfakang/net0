`当在搜索框中输入map.baidu.com到响应的整个过程：`

当在搜索框中输入map.baidu.com到响应的整个过程：
===

* 1：首先对其输入的域名解析解析（DNS）     
    * DNS 涉及到了一个DNS劫持技术：
      * 就是在进行域名解析的时候，通过修改域名对应的ip的值就可以使用户访问你设置的网站了.
    * 1.1若本地有DNS缓存则直接取得对应的ip
    * 1.2若本地无DNS缓存    
* 2：若本地无DNS缓存则浏览器向本机DNS模块发送DNS请求      
 * 注意当使用CDN加速的时候：
```
对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，
为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解 析以得到实际的IP地址；
在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得
用户能就近访问。   
 ```
* 3：DNS将生成的DNS报文传送给传输层的UDP协议单元     
* 4：然后传输到网络层，在此添加了ip（注意是DNS服务器的ip）    
* 5：到达数据链路层，此时需要使用ARP解析得到mac地址，若此时ARP缓存中没有与之对应的ip__mac映射，
 则要向此局域网发一个ARP广播。      
 * 此处涉及到一个ARP欺骗技术：　　　
```
ARP欺骗原理 我们先模拟一个环境： 网关：192.168.1.1 MAC地址：00:11:22:33:44:55 
欺骗主机A：192.168.1.100 MAC地址：00:11:22:33:44:66 被欺骗主机B：192.168.1.50 MAC地址:
00:11:22:33:44:77 欺骗主机A不停的发送ARP应答包给网关，告诉网关他是192.168.1.50主机B，这
样网关就相信欺骗主机，并且在网关的ARP缓存表里就有 192.168.1.50 对应的MAC就是欺骗主机A的
MAC地址00:11:22:33:44:66，网关真正发给主机B的流量就转发给主机A；另外主机A同时不停的向主
机B发 送ARP请求，主机B相信主机A为网关，在主机B的缓存表里有一条记录为192.168.1.1对应
00:11:22:33:44:66，这样主机B真正 发送给网关的数据流量就会转发到主机A；等于说主机A和网关
之间的通讯就经过了主机A，主机A作为了一个中间人在彼此之间进行转发，这就是ARP欺骗。
```

* 6：若目标机器不在此局域网内，则要跳转到下一跳路由        
* 7：当DNS服务器收到该数据包的时候，通过DNS服务器产生一个DNS响应报文，在此写回去    
* 8:当期本地DNS模块收到DNS响应报文过后，把其写入本地DNS缓存      
* 9：然后进行tcp的三次握手过程（首先浏览器向www.map.baidu.com发出tcp请求报文SYN）当完成了
三次握手过后就进行http的发送了       
  * 在三次握手的过程当中：
```
     第一次首先发送一个SYN同步报文给对方，此时当服务器端收到SYN报文的时候服务器就回应
     一个ACK/syn报文，最后客户端在此向服务器端回应一个ACK报文 才完成了整个三次握手过程。    
     SYN Flood技术就是利用第二次握手的时候，由于在第二次握手的时候服务器端会去为该来分配
    一个TCB资源，用于记录该半打开链接。（当server回应了SYN/ACK的时候在client端也会分配一
    个TCB资源，只有当一个连接超时了才会去删除的，所以只要攻击端发送SYN报文的速度快于超时时
    间就可以耗尽server端的资源。正是利用这种不平等的关系进行攻击的）        
```
 * 如何来解决： 

    ```
     1：检测半打开半打开连接数      
     2：检测新连接速度     
     3：SYN  Cookie技术：就是在client与server之间使用防火墙作为代理。是client发送的syn时防火
     墙截取此SYN并模仿服务器进行回应（此时防火墙会先把ack序列号进行相关的加密计算cookie，最后
     防火墙根据client回应的ack计算看与之是否匹配）     
     4：safte  Reset技术：当防火墙截取到了client的SYN的时候，通过回应与之client不期望的序列号
     从而client会发送rst报文，防火墙进行相应的cookie判断从而认定该client是可信的，之后client在
     此发送SYN当防火墙根据cookie检测直接进行放行就ok了。此技术与SYN cookie技术相比要好的多。原因
     是此时防火墙相当于一个但向代理，后期的数据传输很快，不需要向SYN cookie哪种方式转发了    
```

* 10：浏览器发出http请求，然后通过后面的nginx进行相应的调度到相应的后台Apache上去，当Apache收到请
求后会把其交给一个进程来处理          
 * nginx的worker进程的处理方式：　　
 
```
      每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）
      之后， 然后再fork出多个worker进程。所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一
      个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册
      listenfd读事件，在读事件里调用 accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取
      请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才 断开连接，这样一个完整的请求就是这样
      的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。
```

* 11：当期处理完毕过后就要进行响应了(即服务器返回数据给浏览器)

 * 注意当使用CDN加速的时候：
```
对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际IP地址，浏览
器需要再次对获得的CNAME域名进行解 析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根\
据地理位置信息解析对应的IP地址，使得用户能就近访问。
```

到这里为止相关处理过程就完了．

Http请求返回状态码：　　
===

1xx 代表请求已被接受，需要继续处理．　　　　　　　　

2xx 代表请求已成功被服务器接收、理解、并接受．

3xx 这类状态码代表需要客户端采取进一步的操作才能完成请求．

4xx 代表了客户端看起来可能发生了错误，妨碍了服务器的处理．

5xx 代表了服务器在处理请求的过程中有错误或者异常状态发生, 无法完成请求．


相关字段的含义：　
===

* 请求头字段：　　　

 * Accept：告诉web服务器自己接受什么样的类型．

 * Cookie：是由服务器生成，发送给浏览器，浏览器会将此cookie保存在本地文件，下次再访问这个网站的时候就会发送这个
cookie给server 不用授权了  保持了session状态．

 * Refere：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求的网址/URL．



* 响应头字段：　　　　　

 * Cache-Control：public(可以用 Cached 内容回应任何用户)　

 * private（只能用缓存内容回应先前请求该内容的那个用户）

 * no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）

 * Content_Length：WEB 服务器告诉浏览器自己响应的对象的长度

 * Date：表示消息发送的时间

 * Expires：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，
才能用来响应客户请求

 * Server: WEB 服务器表明自己是什么软件及版本等信息　　








　

欢迎一起交流学习 
====
 
在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流

* 邮件(1031379296#qq.com, 把#换成@)
* QQ: 1031379296
* weibo: [@王发康](http://weibo.com/u/2786211992/home)


Thx
====

* chunshengsterATgmail.com


Author
====
* Linux\nginx\golang\c\c++爱好者
* 欢迎一起交流  一起学习# 
* Others say good and Others good


